use crate::context::{
    动态拆分项, 固定拆分项, 字源上下文, 字源决策, 字源决策变化, 最大码长, 空格, 进制,
};
use chai::{encoders::编码器, 元素, 元素映射, 棱镜, 编码信息, 错误};
use rustc_hash::FxHashMap;
use std::iter::zip;

pub struct 字源编码器 {
    pub 固定拆分: Vec<固定拆分项>,
    pub 动态拆分: Vec<动态拆分项>,
    pub 块转数字: FxHashMap<String, usize>,
    pub 数字转块: FxHashMap<usize, String>,
    pub 编码空间: Vec<u8>,
    pub 棱镜: 棱镜,
}

impl 字源编码器 {
    pub fn 新建(上下文: &字源上下文) -> Result<Self, 错误> {
        let 编码空间大小 = 进制.pow(最大码长 as u32) as usize;
        let 全码空间 = vec![u8::default(); 编码空间大小];
        Ok(Self {
            动态拆分: 上下文.动态拆分.clone(),
            固定拆分: 上下文.固定拆分.clone(),
            块转数字: 上下文.块转数字.clone(),
            数字转块: 上下文.数字转块.clone(),
            编码空间: 全码空间,
            棱镜: 上下文.棱镜.clone(),
        })
    }

    pub fn 构建元素序列(&self, 决策: &字源决策, 拆分序列: &mut [[元素; 4]]) {
        let 映射 = 决策.线性化(&self.棱镜);
        let mut 当前拆分索引 = vec![0_usize; self.动态拆分.len()];
        for (块序号, 拆分方式列表) in self.动态拆分.iter().enumerate() {
            if 块序号 == usize::MAX {
                continue;
            }
            let mut 找到 = false;
            for (拆分方式序号, 拆分方式) in 拆分方式列表.iter().enumerate() {
                if 拆分方式.iter().all(|x| *x == 0 || 映射[*x] != 0) {
                    当前拆分索引[块序号] = 拆分方式序号;
                    找到 = true;
                    break;
                }
            }
            if !找到 {
                let 块 = &self.数字转块[&块序号];
                let 拆分方式 = 拆分方式列表.last().unwrap().map(|x| {
                    if x == 0 {
                        "".to_string()
                    } else {
                        self.棱镜.数字转元素[&x].clone()
                    }
                });
                panic!("未找到 {块:?} 的映射: {拆分方式:?}\n当前决策为: {决策:?}",);
            }
        }
        // 刷新单字元素序列
        for (序列, 固定拆分项) in zip(拆分序列.iter_mut(), &self.固定拆分) {
            if 固定拆分项.词长 != 1 {
                continue;
            }
            *序列 = [0; 4];
            let mut index = 0;
            for 块序号 in 固定拆分项.字块 {
                if 块序号 == usize::MAX {
                    break;
                }
                for 元素 in self.动态拆分[块序号][当前拆分索引[块序号]] {
                    if 元素 == 0 {
                        break;
                    }
                    序列[index] = 元素;
                    if index <= 2 {
                        index += 1;
                    }
                }
            }
            if 序列[1] == 0 {
                序列[1] = 固定拆分项.拼音.0;
                序列[2] = 固定拆分项.拼音.1;
            } else if 序列[2] == 0 {
                序列[2] = 固定拆分项.拼音.0;
            } else if 序列[3] == 0 {
                序列[3] = 固定拆分项.拼音.0;
            }
        }
        // 刷新多字词元素序列
        for (索引, 固定拆分项) in self.固定拆分.iter().enumerate() {
            if 固定拆分项.词长 == 1 {
                continue;
            }
            let mut 序列 = [0; 4];
            if 固定拆分项.字块[2] == usize::MAX {
                序列[0] = 拆分序列[固定拆分项.字块[0]][0];
                序列[1] = 拆分序列[固定拆分项.字块[0]][1];
                序列[2] = 拆分序列[固定拆分项.字块[1]][0];
                序列[3] = 拆分序列[固定拆分项.字块[1]][1];
            } else if 固定拆分项.字块[3] == usize::MAX {
                序列[0] = 拆分序列[固定拆分项.字块[0]][0];
                序列[1] = 拆分序列[固定拆分项.字块[1]][0];
                序列[2] = 拆分序列[固定拆分项.字块[2]][0];
                序列[3] = 拆分序列[固定拆分项.字块[2]][1];
            } else {
                序列[0] = 拆分序列[固定拆分项.字块[0]][0];
                序列[1] = 拆分序列[固定拆分项.字块[1]][0];
                序列[2] = 拆分序列[固定拆分项.字块[2]][0];
                序列[3] = 拆分序列[固定拆分项.字块[3]][0];
            }
            拆分序列[索引] = 序列;
        }
    }

    pub fn 重置空间(&mut self) {
        self.编码空间.iter_mut().for_each(|x| {
            *x = 0;
        });
    }

    #[inline(always)]
    fn 全码规则(元素序列: &[元素; 4], 映射: &元素映射) -> u64 {
        映射[元素序列[0]]
            + (映射[元素序列[1]]) * 进制
            + (映射[元素序列[2]]) * 进制 * 进制
            + (映射[元素序列[3]]) * 进制 * 进制 * 进制
    }

    fn 输出全码(
        &mut self, 编码结果: &mut [编码信息], 决策: &字源决策, 拆分序列: &[[元素; 4]]
    ) {
        let 映射 = 决策.线性化(&self.棱镜);
        for (序列, 编码信息) in zip(拆分序列, 编码结果.iter_mut()) {
            let 全码信息 = &mut 编码信息.全码;
            全码信息.原始编码 = Self::全码规则(序列, &映射);
            全码信息.原始编码候选位置 = self.编码空间[全码信息.原始编码 as usize];
            self.编码空间[全码信息.原始编码 as usize] += 1;
            全码信息.选重标记 = 全码信息.原始编码候选位置 > 0;
        }
    }

    fn 输出简码(&mut self, 编码结果: &mut [编码信息]) {
        for (_序号, 编码信息) in 编码结果.iter_mut().enumerate() {
            if 编码信息.词长 > 1 {
                continue;
            }
            let 全码 = 编码信息.全码.原始编码;
            // 一级简码（空格）
            let 一简 = 全码 % 进制 + 空格 * 进制;
            if self.编码空间[一简 as usize] == 0 {
                编码信息.简码.原始编码 = 一简;
                self.编码空间[一简 as usize] += 1;
                continue;
            }
            if 全码 > 进制 * 进制 {
                // 二级简码
                let 二简 = 全码 % (进制 * 进制) + 空格 * 进制 * 进制;
                if self.编码空间[二简 as usize] == 0 {
                    编码信息.简码.原始编码 = 二简;
                    self.编码空间[二简 as usize] += 1;
                    continue;
                }
            }
            if 全码 > 进制 * 进制 * 进制 {
                // 三级简码
                let 三简 = 全码 % (进制 * 进制 * 进制) + 空格 * 进制 * 进制 * 进制;
                if self.编码空间[三简 as usize] == 0 {
                    编码信息.简码.原始编码 = 三简;
                    self.编码空间[三简 as usize] += 1;
                    continue;
                }
            }
            // 无简码
            编码信息.简码.原始编码 = 全码;
        }
    }

    pub fn 动态编码(
        &mut self, 决策: &字源决策, 拆分序列: &[[元素; 4]], 输出: &mut [编码信息]
    ) {
        self.重置空间();
        self.输出全码(输出, 决策, 拆分序列);
        self.输出简码(输出);
    }
}

impl 编码器 for 字源编码器 {
    type 解类型 = 字源决策;
    fn 编码(
        &mut self,
        _决策: &字源决策,
        _决策变化: &Option<字源决策变化>,
        _输出: &mut [编码信息],
    ) {
        self.重置空间();
    }
}
